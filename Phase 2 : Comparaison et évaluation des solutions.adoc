= S2.02 - Exploration algorithmique d‚Äôun probl√®me 
Auteur : Lekesiz Mucahit
:toc:
:toc-title: Sommaire

== √âvaluation des Algorithmes

=== Evaluation des algorithmes de simplicit√©
|====
| Algorithme | Compile | Anonymat | Fonctionne | Test | Remarque | Note

| 05simplicite.java | Oui | Oui | Oui | Oui |  | 18
| 48simplicite.java | Oui | Oui | Oui | Oui |  | 18
| 54simplicite.java | Compile seulement pour RLE
| Oui | Retour erron√© | Ne passe pas | Les m√©thodes pour d√©compresser un caract√®re ne sont pas pr√©sents, unRLE(string in) et unRLE(string in, int iterations). Donc le code ne compile pas, les tests ne passent pas. Le nom de la m√©thode avec iterations de RLE n‚Äôest pas le m√™me que celui initialement donn√©e . Sinon le code est comment√© et lisible.
 | 5
| 26simplicite.py   | Oui | Oui | Oui | Oui |  | 18
| 65simplicite.py   | Oui | Oui | Oui | Ne passe pas tous les tests | | 12
|====

=== Evaluation des algorithmes d'efficacit√©
|====
| Algorithme | Compile | Anonymat | Fonctionne | Test | Remarque | Note

| 25efficacite.java | Oui | Oui | Oui | Passe tout les tests sauf deux test de UnRleRecursif | Code comment√©. Nom de classe appel√© Efficacite | 14
| 30efficacite.java | Oui | Oui | Oui | Oui | | 18
| 65efficacite.java | AlgoException | Oui | Fonctionne seulement pour RLE classique, exception lev√© pour RleR√©cursif | Ne passe pas | Le nom de la classe est appel√© Efficacit√©. Les Exceptions AlgoException ne sont pas g√©r√©s par les m√©thodes RLEr√©cursif, UnRLE et UnRLEr√©cursif. L‚Äôalgorithme ne g√®re pas le cas o√π la cha√Æne est vide. L‚Äôalgorithme compile et fonctionne mais ne passe pas tous les tests initalement fournis. | 7
| 01efficacite.c   Oui| Oui| Oui| | | | 
| 34efficacite.c   Oui| Oui| Oui| | | | 
|====

=== Evaluation des algorithmes de sobri√©t√©
|====
| Algorithme | Compile | Anonymat | Fonctionne | Test | Remarque | Note

| 12sobriete.java | AlgoException | Oui | Oui | Oui | Le nom de la classe est appel√© Sobriete. Les exceptions AlgoException ne sont pas g√©r√©s par les m√©thodes RLEr√©cursif, UnRLE et UnRLEr√©cursif.  Mis √† part les Exceptions l‚Äôalgorithme fonctionne, compile et passe tous les tests fournis initialement. | 12
| 25sobriete.java | Oui | Oui | Oui | Oui | Le nom de la classe est appel√© Sobriete. Le code est lisible et comment√©. L‚Äôalgo compile, fonctionne et passe tous les tests initialement fournis | 18
| 47sobriete.java | AlgoException | Oui | Oui | Oui| Le nom de la classe est appel√© Sobriete. Les exceptions AlgoException ne sont pas g√©r√©s par les m√©thodes RLEr√©cursif, UnRLE et UnRLEr√©cursif.  Mis √† part les Exceptions l‚Äôalgo fonctionne, compile et passe tous les tests fournis initialement. Le code est lisible et comment√©| 13
| 63sobriete.java | Oui | Oui | Oui | Oui | | 18
|====

Remarque Globale : Parmi les algorithmes √©valu√©s, certains ne compilaient pas en raison de l'absence des exceptions AlgoException dans les m√©thodes, ce qui emp√™chait le bon fonctionnement du code et le lancement des tests. Pour ces algorithmes, j'ai ajout√© les exceptions AlgoException afin de v√©rifier leur bon fonctionnement, en retirant 5 points √† chacun. De plus, pour tous les codes o√π le nom de la classe n'√©tait pas 'Algo', j'ai enlev√© 1 point. Enfin, pour les algorithmes dont le code √©tait comment√© et lisible, j'ai ajout√© 1 point.
Pour les algos de la cat√©gorie Efficacit√© je n'ai pas enlev√© de point, ils respectaient la consigne sur les m√©hodes de java.util.


== Pr√©sentation des outils d‚Äô√©valuation 

== Classement des Algorithmes

=== Classement par Simplicit√©
[cols="1,1,1,1", options="header"]
|===
|Classement |Algorithme |Points positifs |Am√©lioration
|1 |26simplicite.py |Bien structur√©, lisible et simple, gestion correcte des it√©rations | Manque de gestion des exceptions, les commentaires peuvent √™tre am√©lior√©s pour plus de lisiblit√©.
|2 |05simplicite.java |Code simple et fonctionnel | Le manque de commentaire rend le code moins lisible
|3 |48simplicite.java |Code simple et fonctionnel|
Quelques r√©p√©titions inutiles et manque de commentaires pour plus de lisibilit√©
|4 |65.simplicite.py |Code structur√© et simple| Absence de gestion des exceptions, manque de commentaires pour plus de lisibilit√©
|5 |54.simplicite.java| Code correct | Quelques inefficacit√©s, absence de gestion des exceptions, manque de commentaires.
|===

=== Classement par Efficacit√©
|===
|Classement |Algorithme |Temps d'ex√©cution | Commentaires
|1 |01efficacite.py| 0.01ms pour la cha√Æne de caract√®re 'abc', 0.015ms pour la cha√Æne de caract√®re 'aaabc' |Utilisation efficace de malloc et realloc pour la bonne gestion de la m√©moire.
|2 |34efficacite.py| Entre 0.020ms et 0.030ms pour la cha√Æne de caract√®re 'abc', entre 0.020ms et 0.030ms pour la cha√Æne de caract√®re 'aaabc' |Utilisation efficace de malloc et realloc pour la bonne gestion de la m√©moire.
|3 |30efficacite.java |Nb Iteration 5 : 0.16954ms Nb Iteration 15 : 0.7093ms |Impl√©mentation simple des fonctions RLE et unRLE, utilisation efficace de boucles pour la compression et la d√©compression.
|4 |25efficacite.java |Nb Iteration 5 : 0.44577ms Nb Iteration 15 : 0.86191ms |Facile √† comprendre et √† utiliser. Code lisible et comment√©. Utilisation de StringBuilder pour am√©liorer la performance de la concat√©nation de cha√Ænes, gestion des exceptions pour les it√©rations n√©gatives.
|5 |65efficacite.java |Nb Iteration 5 : 0.48957ms Nb Iteration 15 : 2.14028ms |Utilisation de la r√©cursivit√© pour traiter les it√©rations multiples. Gestion insuffisante des cas sp√©ciaux comme les cha√Ænes vides ou les it√©rations n√©gatives, utilisation inefficace de la concat√©nation de cha√Ænes dans des boucles.
|===
Pour mesurer la performance des algorithmes de la cat√©gorie "Efficacit√©", j'ai utilis√© un programme Java permettant le calcul des temps d'ex√©cution. Le programme mesure le temps d'ex√©cution de l'algorithme RLE r√©cursif en l'appelant 10 fois en prenant en param√®tres la chaine de caract√®re et le nombre d'it√©rations. Il calcule ensuite la dur√©e totale en nanosecondes et millisecondes, affiche les r√©sultats ou un message d'erreur en cas d'exception. Le classement est bas√© sur la rapidit√© de chaque algorithme. Cependant le temps d'ex√©cution n'est pas le seul crit√®re du classement, d'autres crit√®res tels que la facilit√© d'impl√©mentation et la lisibilit√© du code sont √©galement pris en compte. 

=== Classement par Sobri√©t√©
|===
|Classement |Algorithme |Commentaire
|1 |25sobriete.java | Utilisation efficace de la m√©moire avec des tableaux de caract√®res.
Complexit√© temporelle lin√©aire ùëÇ(ùëõ)
|2 |47sobriete.java | Utilisation de StringBuilder pour une gestion efficace de la m√©moire.
Complexit√© temporelle lin√©aire ùëÇ(ùëõ)
|3 |65sobriete.java | Utilisation de StringBuilder pour la construction des cha√Ænes.
Complexit√© temporelle lin√©aire ùëÇ(ùëõ)
|4 |25sobriete.java | Concat√©nation de cha√Ænes r√©p√©t√©e dans les boucles, pas tr√®s efficace en terme de performances m√©moire
|===
